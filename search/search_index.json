{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"assign_id_to_group_consecutive_seq/","title":"Assign id to slices of consecutive sequences number","text":"<p>Given :</p> group_id seq SEC20_N_0 1 SEC20_N_0 2 SEC20_N_0 6 SEC20_N_0 8 SEC20_N_0 9 SEC20_N_0 10 <p>Assign a id to the slice of consecutive sequence numbers</p> <p>Answer :</p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES ('SEC20_N_0', 1)\n,('SEC20_N_0', 2)\n,('SEC20_N_0', 6)\n,('SEC20_N_0', 8)\n,('SEC20_N_0', 9)\n,('SEC20_N_0', 10)\n) group_sequence(group_id, seq)\n), base_with_previous_sequence AS (\nSELECT *\n,LAG(seq,1,0) OVER (PARTITION BY group_id ORDER BY seq) as previous_seq\n-- If the current sequence - 1 is equals to previous value , then it means no gap \n-- Else it means that there is a gap so we return 1\n,CASE WHEN seq - 1 = LAG(seq,1,1) OVER (PARTITION BY group_id ORDER BY seq) THEN 0  ELSE 1  END AS diff\nFROM base\n), base_with_lot_id AS (\nSELECT * -- Sum the diff , after each gap , the lot_id increases by 1\n, SUM(diff) OVER (PARTITION BY group_id ORDER BY seq) AS lot_id\nFROM base_with_previous_sequence\n)\nSELECT * FROM base_with_lot_id;\n</code></pre> group_id seq previous_seq diff lot_id SEC20_N_0 1 0 1 1 SEC20_N_0 2 1 0 1 SEC20_N_0 6 2 1 2 SEC20_N_0 8 6 1 3 SEC20_N_0 9 8 0 3 SEC20_N_0 10 9 0 3"},{"location":"bonus/","title":"Bonus","text":""},{"location":"bonus/#bonus-examples","title":"Bonus examples :","text":""},{"location":"bonus/#running-vs-total-sum-per-partition","title":"Running Vs Total Sum per partition :","text":"<p>This is a classic example to show the importance of the \"window\". </p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1,1,1),\n(1, 1,  2),\n(1, 1,  3),\n(1, 1,  4),\n(2, 1,  1),\n(2, 1,  2),\n(2, 1,  3),\n(3, 1,  1),\n(3, 1,  2)\n) as t (pk , value, version)\n)\nSELECT * FROM (\nSELECT t1.*, SUM(value) OVER( PARTITION BY pk ORDER BY version) as running_sum\nFROM base t1\n) as t\nORDER BY pk , version;\n</code></pre> pk value version running_sum 1 1 1 1 1 1 2 2 1 1 3 3 1 1 4 4 2 1 1 1 2 1 2 2 2 1 3 3 3 1 1 1 3 1 2 2 <p>Notice how there is no window clause defined . This means that the default window is RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW.  So in this case , it's not required to specify it .  However, if we wanted a total sum , then we would need to specify the clause as follows :</p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1,1,1),\n(1, 1,  2),\n(1, 1,  3),\n(1, 1,  4),\n(2, 1,  1),\n(2, 1,  2),\n(2, 1,  3),\n(3, 1,  1),\n(3, 1,  2)\n) as t (pk , value, version)\n)\nSELECT * FROM (\nSELECT t1.*, SUM(value) OVER( PARTITION BY pk ORDER BY version RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as total_sum_per_partition\nFROM base t1\n) as t\nORDER BY pk , version;\n</code></pre> <p>End Result:</p> pk value version total_sum_per_partition 1 1 1 4 1 1 2 4 1 1 3 4 1 1 4 4 2 1 1 3 2 1 2 3 2 1 3 3 3 1 1 2 3 1 2 2"},{"location":"bonus/#de-duplication","title":"De-duplication","text":"<p>We have used the function RANK in this example .. but what would happen if there was a duplicate of the latest version . </p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1, 'value4',    4),\n(1, 'value5',   4),\n(2, 'value3',   3),\n(2, 'value4',   3)  ) AS t (pk , value, version)\n)\nSELECT * FROM (\nSELECT t1.*, RANK() OVER( PARTITION BY pk ORDER BY version desc ) as rank\nFROM base t1\n) AS t\nWHERE rank = 1; </code></pre> pk value version rank 1 value4 4 1 1 value5 4 1 2 value3 3 1 3 value4 2 1 <p>We would be showing both ! </p> <p>Now if you ever heard a fancy word such as <code>deduplication</code> then all we would need to do is to use the ROW_NUMBER function instead</p> <p>Returns an ascending sequence of integers, starting with 1.  Starts the sequence over for each group produced by the PARTITIONED BY clause.  The output sequence includes different values for duplicate input values.  Therefore, the sequence never contains any duplicates or gaps, regardless of duplicate input values</p> <p>https://impala.apache.org/docs/build/html/topics/impala_analytic_functions.html#row_number</p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1, 'value4',    4),\n(1, 'value5',   4),\n(2, 'value3',   3),\n(2, 'value4',   3)  ) AS t (pk , value, version)\n)\nSELECT * FROM (\nSELECT t1.*, ROW_NUMBER() OVER( PARTITION BY pk ORDER BY version desc ) as rank\nFROM base t1\n) AS t\nWHERE rank = 1; </code></pre> <p>End result :</p> pk value version rank 2 value3 3 1 1 value4 4 1"},{"location":"bonus/#propagating-values","title":"Propagating values","text":"<p>Sometimes there a a need to propagate values from previous row into subsequent rows. </p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1, 'value1',1),\n(1, null,   2),\n(1, null,   3),\n(1, 'value4',   4),\n(2, 'value1',   1),\n(2, null,   2),\n(2, 'value3',   3),\n(3, 'value1',   1),\n(3, 'value2',   2)\n) t(pk , value, version)\n)\nSELECT * FROM base ORDER BY pk , version;\n</code></pre> pk value version 1 value1 1 1 2 1 3 1 value4 4 2 value1 1 2 2 2 value3 3 3 value1 1 3 value2 2 <p>Now let's say we want to fill in the blank values from previous non null value for the same pk. </p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1, 'value1', 1),\n(1, null,   2),\n(1, null,   3),\n(1, 'value4',   4),\n(2, 'value1',   1),\n(2, null,   2),\n(2, 'value3',   3),\n(3, 'value1',   1),\n(3, 'value2',   2)\n) t(pk, value, version) )\nSELECT * FROM (\nSELECT t1.*, LAST_VALUE(value IGNORE NULLS) OVER( PARTITION BY pk ORDER BY version ) as propagated_value    FROM base t1\n) AS t\nORDER BY pk , version\n</code></pre> <p>End Result:</p> pk value version propagated_value 1 value1 1 value1 1 2 value1 1 3 value1 1 value4 4 value4 2 value1 1 value1 2 2 value1 2 value3 3 value3 3 value1 1 value1 3 value2 2 value2"},{"location":"bonus/#previous-value","title":"Previous value","text":"<p>Another classic usage of window function is to retrieve a value from the previous row. This can be achieved through the LAG function.  Having the previous value enables all sort of delta calculation which would fit use cases such as time elapsed and  gaps in sequence.</p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1,1,1),\n(1, 2,  2),\n(1, 4,  3),\n(1, 5,  4),\n(2, 1,  1),\n(2, 2,  2),\n(2, 3,  3),\n(3, 1,  1),\n(3, 5,  2)\n) t (pk , value, version)\n)\nSELECT * FROM base\nORDER BY pk , version\n</code></pre> pk value version 1 1 1 1 2 2 1 4 3 1 5 4 2 1 1 2 2 2 2 3 3 3 1 1 3 5 2 <p>Here is an an example where I would retrieve the previous value from a sequence and calculate the delta . This would detect if there is a gap in the sequence.</p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1,1,1),\n(1, 2,  2),\n(1, 4,  3),\n(1, 5,  4),\n(2, 1,  1),\n(2, 2,  2),\n(2, 3,  3),\n(3, 1,  1),\n(3, 5,  2)\n) t(pk , value, version)\n)\nSELECT t.*, value - previous_value as delta FROM (\nSELECT t1.*, LAG(value, 1) OVER( PARTITION BY pk ORDER BY version) AS previous_value\nFROM base t1\n) as t\nORDER BY pk , version\n</code></pre> pk value version previous_value delta 1 1 1 1 2 2 1 1 1 4 3 2 2 1 5 4 4 1 2 1 1 2 2 2 1 1 2 3 3 2 1 3 1 1 3 5 2 1 4"},{"location":"deduplication/","title":"Deduplication","text":""},{"location":"deduplication/#deduplication","title":"Deduplication","text":"<p>We have used the function RANK in this example .. but what would happen if there was a duplicate of the latest version . </p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1, 'value4',    4),\n(1, 'value5',   4),\n(2, 'value3',   3),\n(2, 'value4',   3)  ) AS t (pk , value, version)\n)\nSELECT * FROM (\nSELECT t1.*, RANK() OVER( PARTITION BY pk ORDER BY version desc ) as rank\nFROM base t1\n) AS t\nWHERE rank = 1; </code></pre> pk value version rank 1 value4 4 1 1 value5 4 1 2 value3 3 1 3 value4 2 1 <p>We would be showing both ! </p> <p>Now if you ever heard a fancy word such as <code>deduplication</code> then all we would need to do is to use the ROW_NUMBER function instead</p> <p>Returns an ascending sequence of integers, starting with 1.  Starts the sequence over for each group produced by the PARTITIONED BY clause.  The output sequence includes different values for duplicate input values.  Therefore, the sequence never contains any duplicates or gaps, regardless of duplicate input values</p> <p>https://impala.apache.org/docs/build/html/topics/impala_analytic_functions.html#row_number</p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1, 'value4',    4),\n(1, 'value5',   4),\n(2, 'value3',   3),\n(2, 'value4',   3)  ) AS t (pk , value, version)\n)\nSELECT * FROM (\nSELECT t1.*, ROW_NUMBER() OVER( PARTITION BY pk ORDER BY version desc ) as rank\nFROM base t1\n) AS t\nWHERE rank = 1; </code></pre> <p>End result :</p> pk value version rank 2 value3 3 1 1 value4 4 1"},{"location":"previous_value/","title":"Previous Value","text":""},{"location":"previous_value/#previous-value","title":"Previous value","text":"<p>Another classic usage of window function is to retrieve a value from the previous row. This can be achieved through the LAG function.  Having the previous value enables all sort of delta calculation which would fit use cases such as time elapsed and  gaps in sequence.</p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1,1,1),\n(1, 2,  2),\n(1, 4,  3),\n(1, 5,  4),\n(2, 1,  1),\n(2, 2,  2),\n(2, 3,  3),\n(3, 1,  1),\n(3, 5,  2)\n) t (pk , value, version)\n)\nSELECT * FROM base\nORDER BY pk , version\n</code></pre> pk value version 1 1 1 1 2 2 1 4 3 1 5 4 2 1 1 2 2 2 2 3 3 3 1 1 3 5 2 <p>Here is an an example where I would retrieve the previous value from a sequence and calculate the delta . This would detect if there is a gap in the sequence.</p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1,1,1),\n(1, 2,  2),\n(1, 4,  3),\n(1, 5,  4),\n(2, 1,  1),\n(2, 2,  2),\n(2, 3,  3),\n(3, 1,  1),\n(3, 5,  2)\n) t(pk , value, version)\n)\nSELECT t.*, value - previous_value as delta FROM (\nSELECT t1.*, LAG(value, 1) OVER( PARTITION BY pk ORDER BY version) AS previous_value\nFROM base t1\n) as t\nORDER BY pk , version\n</code></pre> pk value version previous_value delta 1 1 1 1 2 2 1 1 1 4 3 2 2 1 5 4 4 1 2 1 1 2 2 2 1 1 2 3 3 2 1 3 1 1 3 5 2 1 4"},{"location":"running_vs_total/","title":"Running vs Total Sum","text":""},{"location":"running_vs_total/#running-vs-total-sum-per-partition","title":"Running Vs Total Sum per partition :","text":"<p>This is a classic example to show the importance of the \"window\". </p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1,1,1),\n(1, 1,  2),\n(1, 1,  3),\n(1, 1,  4),\n(2, 1,  1),\n(2, 1,  2),\n(2, 1,  3),\n(3, 1,  1),\n(3, 1,  2)\n) as t (pk , value, version)\n)\nSELECT * FROM (\nSELECT t1.*, SUM(value) OVER( PARTITION BY pk ORDER BY version) as running_sum\nFROM base t1\n) as t\nORDER BY pk , version;\n</code></pre> pk value version running_sum 1 1 1 1 1 1 2 2 1 1 3 3 1 1 4 4 2 1 1 1 2 1 2 2 2 1 3 3 3 1 1 1 3 1 2 2 <p>Notice how there is no window clause defined . This means that the default window is RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW.  So in this case , it's not required to specify it .  However, if we wanted a total sum , then we would need to specify the clause as follows :</p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1,1,1),\n(1, 1,  2),\n(1, 1,  3),\n(1, 1,  4),\n(2, 1,  1),\n(2, 1,  2),\n(2, 1,  3),\n(3, 1,  1),\n(3, 1,  2)\n) as t (pk , value, version)\n)\nSELECT * FROM (\nSELECT t1.*, SUM(value) OVER( PARTITION BY pk ORDER BY version RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as total_sum_per_partition\nFROM base t1\n) as t\nORDER BY pk , version;\n</code></pre> <p>End Result:</p> pk value version total_sum_per_partition 1 1 1 4 1 1 2 4 1 1 3 4 1 1 4 4 2 1 1 3 2 1 2 3 2 1 3 3 3 1 1 2 3 1 2 2"},{"location":"value_propagation/","title":"Value Propagation","text":""},{"location":"value_propagation/#propagating-values","title":"Propagating values","text":"<p>Sometimes there a a need to propagate values from previous row into subsequent rows. </p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1, 'value1',1),\n(1, null,   2),\n(1, null,   3),\n(1, 'value4',   4),\n(2, 'value1',   1),\n(2, null,   2),\n(2, 'value3',   3),\n(3, 'value1',   1),\n(3, 'value2',   2)\n) t(pk , value, version)\n)\nSELECT * FROM base ORDER BY pk , version;\n</code></pre> pk value version 1 value1 1 1 2 1 3 1 value4 4 2 value1 1 2 2 2 value3 3 3 value1 1 3 value2 2 <p>Now let's say we want to fill in the blank values from previous non null value for the same pk. </p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1, 'value1', 1),\n(1, null,   2),\n(1, null,   3),\n(1, 'value4',   4),\n(2, 'value1',   1),\n(2, null,   2),\n(2, 'value3',   3),\n(3, 'value1',   1),\n(3, 'value2',   2)\n) t(pk, value, version) )\nSELECT * FROM (\nSELECT t1.*, LAST_VALUE(value IGNORE NULLS) OVER( PARTITION BY pk ORDER BY version ) as propagated_value    FROM base t1\n) AS t\nORDER BY pk , version\n</code></pre> <p>End Result:</p> pk value version propagated_value 1 value1 1 value1 1 2 value1 1 3 value1 1 value4 4 value4 2 value1 1 value1 2 2 value1 2 value3 3 value3 3 value1 1 value1 3 value2 2 value2"},{"location":"window_functions/","title":"Window Functions","text":""},{"location":"window_functions/#window-functions","title":"Window Functions","text":""},{"location":"window_functions/#why-the-need","title":"Why the need ?","text":"<p>If you were giving this dataset and were asked to provide me an SQL query which will for every distinct <code>pk</code> , return me the columns <code>value</code> and <code>version</code> corresponding to the highest <code>version</code>, what would you answer be ?</p> pk value version 1 value1 1 1 value2 2 1 value3 3 1 value4 4 2 value1 1 2 value2 2 2 value3 3 3 value1 1 3 value2 2 <p>Let's first build the dataset to play on.</p> <p>If you are unfamiliar with the WITH clause , you can refer to https://en.wikipedia.org/wiki/Hierarchical_and_recursive_queries_in_SQL#Common_table_expression</p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1, 'value1',1),\n(1, 'value2',   2),\n(1, 'value3',   3),\n(1, 'value4',   4),\n(2, 'value1',   1),\n(2, 'value2',   2),\n(2, 'value3',   3),\n(3, 'value1',   1),\n(3, 'value2',   2)\n) as t (pk , value, version)\n)\nSELECT * FROM base;\n</code></pre> <p>The query above would create the table <code>base</code> representing the dataset</p> <p>Now to answer the need , there is a good chance we would come up with something similar to the following:</p> <pre><code>SELECT * FROM base t1\nINNER JOIN (\nSELECT pk, MAX(version) AS version\nFROM windowFunctionDemo\nGROUP BY pk\n) AS t2\nON t1.pk = t2.pk AND t1.version = t2.version;\n</code></pre>"},{"location":"window_functions/#takeaway","title":"Takeaway","text":"<ul> <li> <p>Once the max version is retrieved, I lose all the other columns not specified in the <code>GROUP BY</code> clause. </p> </li> <li> <p>This is the reason we have to use the <code>JOIN</code> to get that information back. </p> </li> </ul> <p>However this makes the query much more complicated reading and logic wise.  So,  what if there was a way to keep all the current rows and columns, and  just add the 'max version' as an extra column? We can, with  window/analytics functions.</p>"},{"location":"window_functions/#what-composes-a-window-function","title":"What composes a window function","text":"<p>Window function requires a partition key, and boundaries. <code>ORDER BY</code> is optional. </p> <p>The PARTITION BY clause acts much like the GROUP BY clause in the outermost block of a query.  It divides the rows into groups containing identical values in one or more columns.  These logical groups are known as partitions. </p> <p>The ORDER BY clause works much like the ORDER BY clause in the outermost block of a query.  It defines the order in which rows are evaluated for the entire input set, or for each group produced by a PARTITION BY clause.  You can order by one or multiple expressions, and for each expression optionally choose ascending or descending order and whether nulls come first or last in the sort order. </p> <p>The window clause is only allowed in combination with an ORDER BY clause.  If the ORDER BY clause is specified but the window clause is not, the default window is RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW.</p> <p>For more reference (https://www.cloudera.com/documentation/enterprise/5-8-x/topics/impala_analytic_functions.html)</p> <p>Now if we were to rethink our original problem more in the form of \"I would like to know for each <code>pk</code>, it's highest version and filter that\" , then one choice would be use the RANK() version. Now it would be a question of asking what would be the partition , boundaries and the ordering. With the problem reformulated , we can clearly see that the partition would be <code>pk</code> , the ordering would be by version descending (because we want the highest) and window clause is not required.</p> <pre><code>WITH base AS (\nSELECT * FROM (\nVALUES (1, 'value1',1),\n(1, 'value2',   2),\n(1, 'value3',   3),\n(1, 'value4',   4),\n(2, 'value1',   1),\n(2, 'value2',   2),\n(2, 'value3',   3),\n(3, 'value1',   1),\n(3, 'value2',   2)\n) as t (pk , value, version)\n)\nSELECT * FROM (\nSELECT t1.*, RANK() OVER( PARTITION BY pk ORDER BY version desc ) as rank\nFROM base t1\n) as t\nWHERE rank =1 ORDER BY pk;\n</code></pre> <p>End result</p> pk value version rank 1 value4 4 1 2 value3 3 1 3 value2 2 1"},{"location":"window_functions/#takeaway_1","title":"Takeaway","text":"<ul> <li>We have avoided a self join !</li> <li>An extra column is created as the placeholder for what we need </li> <li>However predicates on those columns is more annoying (using that new column on a WHERE or HAVING clause) , you either need to make a sub-query or a common table expression over it.</li> </ul>"}]}